#lang racket

(require redex
         "mon_judgment.rkt"
         "contract_judgment.rkt"
         "gen_judgment.rkt"
         "pred_judgment.rkt")

(define (gen-term judgment type in-c out-c exp-c)
  (cond
    [(equal? judgment 'mon)
     (let ([list (judgment-holds
                  (mgen 路 ,type ,in-c ,out-c ,exp-c
                        m) m)])
       (list-ref list (random (length list))))]
    [(equal? judgment 'contract)
     (let ([list (judgment-holds
                  (contract 路 ,type ,in-c ,out-c
                        contract) contract)])
       (list-ref list (random (length list))))]
    [(equal? judgment 'predicate)
     (let ([list (judgment-holds
                  (pred 路 ,type ,in-c
                        pred) pred)])
       (list-ref list (random (length list))))]
    [(equal? judgment 'expression)
     (let ([list (judgment-holds
                  (gen 路 ,type ,exp-c
                        e) e)])
       (list-ref list (random (length list))))]))
    
    