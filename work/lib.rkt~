#lang racket

(require redex
         "grammar.rkt"
         "type_judgment.rkt")

(define (flatten-env env)
  (let [(last (last env))]
    (cond 
      [(equal? last '·) env]
      [else (append (remv last env) last)])))

(define-metafunction L
  [(lookup Γ_1 χ_1) ,(lookup-rkt (term Γ_1) (term χ_1))])

(define (lookup-rkt env x)
  (if (equal? env '·)
      #f
      (lookup-helper (flatten-env env) x)))

(define (lookup-helper env x)
  ;(printf "~a~n" env)
  (cond
    [(empty? env) #f]
    [(equal? (first env) x) (second env)]
    [else (lookup-helper (rest env) x)]))

(define-metafunction L
  [(+env Γ_1 χ_1 τ_1) ((χ_1 τ_1) Γ_1)])

(define-metafunction L 
  [(get-bound-var Γ τ) ,(get-bound-var-rkt (term Γ) (term τ))])

(define (get-bound-var-rkt env t)
  (if (equal? env '·)
      #f
      (get-bound-var-helper (flatten-env env) t)))

(define (get-bound-var-helper env t)
  (begin ;(printf "~a~n" env)
         (cond 
           [(equal? (first env) '·) 'error]
           [(equal? t (second (first env))) (first (first env))]
           [else (get-bound-var-rkt (rest env) t)])))

(define (prob n)
  (> n (/ (random 100) 100)))

(define used-sym (box '()))
(define (get-next-sym)
  (let [(out (generate-term L χ 0))]
    (if (member out (unbox used-sym))
        (get-next-sym)
        (begin (set-box! used-sym (append (unbox used-sym) (list out)))
               out))))

(define (random-type)
    (let [(x (random 2))]
      (if (= 0 x) 'num 'bool)))

;; used in language definition with side conidition
;; to ensure that we only attempt to apply functions
;; to values, and not values to values. 
(define (fun? e)
  (let ([term (term ,e)])
    (printf "~a~n" term)
    (judgment-holds
     (type ·
           ,term
           (-> τ ...)))))

;;TESTS
(test-equal
 (judgment-holds
  (type · (λ ((x num)) x)
        τ) τ)
 (list (term (-> num num))))

(test-equal
 (judgment-holds
  (type ·
        ((λ ((x num)) 1) 1)
        τ) τ)
 '(num))

(test-equal
 (judgment-holds
  (type ·
        (λ () 1)
        τ) τ)
 '((-> num)))

(judgment-holds
 (gen · num 0
      e) e)

(judgment-holds
 (gen · (-> num) 0
      e) e)

(judgment-holds
 (gen · (-> num num) 0
      e) e)

(judgment-holds
 (gen · (-> (-> num num)) 0
      e) e)

(judgment-holds
 (gen · (-> (-> num num) (-> num num)) 0
      e) e)

(judgment-holds
 (gen · (-> (-> (-> num num) num)) 0
      e) e)

;; manually add a variable to the environment
(judgment-holds
 (gen ((x num) ·) (-> (-> num num) num) 0
      e) e)

;; typecheck a term generated by "gen" using "type"
(judgment-holds
 (type · 
       ,(first (judgment-holds 
                (gen · num 0 e) e))
       τ) τ)

(judgment-holds
 (type ((x num) ·) (+ 1 x)
       τ) τ)

(define type-list '(num
                    (-> num)
                    (-> num num)
                    (-> (-> num num))
                    (-> num (-> num num))
                    (-> (-> num num) num)
                    (-> (-> num num) (-> num num))
                    bool
                    (-> bool)
                    (-> bool bool)
                    (-> (-> bool bool))
                    (-> bool (-> bool bool))
                    (-> (-> bool bool) bool)
                    (-> (-> bool bool) (-> bool bool))
                    (-> num bool)
                    (-> bool num)
                    (-> (-> bool num))
                    (-> num (-> bool bool))
                    (-> bool (-> num num))
                    (-> (-> bool bool) num)
                    (-> (-> num num) (-> bool bool))))

(define (test depth)
  (for ([τ (in-list type-list)])
    (begin
      (printf "generating terms of type ~a ... " τ)
      (define terms (judgment-holds
       (gen · ,τ ,depth
            e) e))
      (printf "found ~a~n" (length terms)))))

;(test 2) 